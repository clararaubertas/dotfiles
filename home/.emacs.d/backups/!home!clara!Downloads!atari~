FUN WITH THE ATARI 2600 
by Jered

The Atari 2600 was a machine invented in the 1970s to raise children. One
end attached to your TV antenna using an adaptor, and the other end attached
to your child using a joystick. The child would then remain tethered to the
TV for hours playing video games while you went out disco dancing.

To get the machine to work, you needed to buy expensive bricks called game
cartridges which plugged into the front. Kids would eventually get bored
with games and plead for you to buy them new ones. Cartridges were cheaper
than the machine, and it was already attached to your TV, so you bought
them, thus generating a steady revenue stream for Atari, Inc. to squander on
fast cars and leisure suits.

How this all worked was that the Atari 2600 was actually a computer, like
the one that guided the Apollo astronauts to the moon. Game cartridges
contained programs for the computer, consisting of specialized instructions
telling it what to do, much like recipes. Thus little Jimmy's newfound
obsessive desire to shoot space aliens with lasers for four hours a day was
really no different from a fresh baked plate of grandma's oatmeal raisin
cookies, and who doesn't like cookies?

If computers were houses, the 2600 would be a cardboard box in the park. It
had 128 bytes of RAM, just enough to store the first sentence and a half of
this article. The actual computing was done by a 6507 chip, which was like
the 6502 chip in the popular Apple II computer but with a botched lobotomy,
having had twelve of its pins and their associated functions cut off to save
costs. In consequence the 6507 was friendly but a little dopey. It could
address just over 8000 pieces of information, and could comfortably add up
numbers below 256, but anything more required some effort.

Besides the tiny RAM and the brain damaged 6507, the 2600 had a custom Atari
chip called the TIA or Television Interface Adapter. The TIA was what made
the 2600 at all capable of providing some form of entertainment, like the
chain smoking clown magician with two tricks at a kid's birthday party. It
could be configured to generate godawful digital bleeps and boops, or to
produce the necessary signals to draw one single line of a TV picture.

In combination, the 6507, RAM and TIA were an 8-bit electronic flea circus
in a cheap plastic box. The Atari 2600 sold for an obscenely high price
markup until the year 1992, by which time it was extremely obsolete. It made
huge piles of money.

I first got into the Atari 2600 when I was bored watching Youtube one day
and stumbled on a talk by a German hacker who made his own "homebrew" Atari
games. Having nothing better to do, I decided I'd go make an Atari game of
my own. So I downloaded an Atari emulator---a modern computer program that
simulates the 2600---and tried playing a bunch of old Atari games, to see
what they were like. With a few notable exceptions, they were horrible.

In most Atari games, you control a squat stick figure that runs around and
tries to avoid getting hit by things, which invariably results in death.
Typically you can press a button to fire a bullet at the things, possibly
destroying them and increasing your score. These games are basically just
tag, possibly inside of a maze.

I like games that involve exploring a big world and using your wits. So, I
decided to make a game where you fall into a massive cavern, and have to
explore it and find a way out before you run out of air. There are no
bullets or antagonists, just you in the cave with a limited amount of time.
There's some acrobatic and skilled movement required though, so it's not
completely without challenge. So it is basically a big maze, I guess. I
called it "Cavern".

Having decided on my game's theme, I then needed to program it. The easy and
fun part was to design a giant cave, which I did inside a web browser using
a simple web page that I made. The hard but interesting part was to program
the 2600 to do all the things I wanted.

There are two main tasks to do when programming the 2600, telling the TIA
what to draw, and figuring out what in the hell is going on. Programs spend
most of their time scrambling to tell the TIA what to draw. There is a short
amount of time immediately before each TV line to set up the TIA to draw
that line. Then, while it's drawing the line, you can prepare for drawing
the next line. The amount of time you get per line is about 76 clock cycles,
which is enough for maybe twenty 6507 instructions per line. So it is really
quite tight.

After the picture is drawn, the rest of your program has to figure out what
in the hell is going on. Old TV sets worked by scanning a beam back and
forth from top to bottom, side to side. Once the beam had reached the
bottom, it took it a while to go back up to the top and start painting the
next picture. Thus, an Atari program has this time, the "vertical retrace
interval" during which the TV beam is returning to the top of the TV, to do
all of the real work it has to do.

In my case, most of what I needed to do was to update the portion of the
cave that the player could see, determine if they had run into things or
were climbing over things and if so simulate the appropriate physics, check
on their air supply and so on. But before I ran out of time to do more
complicated simulation, I ran out of space to store the instructions!

In all, you only get 4096 bytes in which to store your program's
instructions and data, which amounts to very little room. I ran out almost
immediately and had to make the cave smaller. But in retrospect that was
good, because the cave was really too large originally.

Actually, dealing with the limitations of the 2600 influenced my designs and
ideas a lot, which was frustrating but also occasionally inspirational. For
example, I wanted to simulate lighting, so that you could only see the
portion of the cave immediately around you. I didn't have enough time to
change colors multiple times per line, so I ended up with a horizontal
gradient with only a certain number of rows of the cave visible, which ended
up looking pretty good.

It also required creative problem solving. After I was done with the game, I
was proud of it so decided I wanted it to have a title screen that I signed
with my initials. The trouble is that I was completely out of memory. So, I
designed a little part of the cave that was walled off from the rest and had
the title screen graphics in it, and then started the player off there with
very little air remaining, so that they would die in a few seconds. Then I
configured the program to start them at the true cave entrance after dying,
with a full air supply.

After doing all the programming, I then needed to test the game on a real
Atari instead of just an emulator. I did that by using a special cartridge
with a flash card on it that I put my game on. It needed only a little
tuning to work, then I could make physical cartridges. I just bought a lot
of crappy old games on e-bay, and am now taking them apart and putting in
a new chip containing my game. I even made labels!

All in all, this was a fun little side project. Programming the Atari was
actually interesting because it's so simple that you understand everything
that's happening, and there's a fun interaction between the limitations of
the medium and your design.

BONUS TEASER MATERIAL FOR NERDS

Interested readers can check out the full source code for the game at
github.com/jeredw/cavern, and also find a binary file for playing with in an
emulator.

Reproduced here is the portion of the inner loop that draws each scan line,
which 2600 programmers call a "kernel" (no, really). It was the most
difficult part of the program to come up with and required a lot of tricks.

"Cavern" has bitmapped graphics which scroll around the screen. I did that
by making my own framebuffer using 64 bytes of the precious RAM, since there
is no framebuffer otherwise.

        ; Framebuffer: 64 bytes $90 to $CF.
        ; Each slice maps to PF1 or PF2 at one position per scanline.
        ; xxxx76543210012345677654321001234567xxxx
        ;     |<---->||<---->||<---->||<---->|
        ;       FB0     FB1     FB2     FB3
FB0     ds FBH
FB1     ds FBH
FB2     ds FBH
FB3     ds FBH 

Program code arranges during vertical retrace to make sure that the
framebuffer contains a bitmap with the visible portion of the cave. The job
on each line of the TV picture is then to output the contents of the
framebuffer.

This is done by modifying the graphics registers in the middle of the line
as the raster beam scans across the line, just in time so that they will
show the correct portion of the framebuffer.

The TIA is capable of using 20 bits of data per line to render a playfield
for a game, like a boxy tennis court for a Pong clone. Actually this
playfield is 40 bits wide, with the 20 defining bits either mirrored or
repeated on both halves of the line. Most games with a playfield would set
up the bitmap in the playfield registers PF0-PF2 once, at the beginning of
the line. To draw my framebuffer, I updated the contents of PF1 and PF2 just
before the TIA started drawing each part.

Probably you'll need to understand a lot more about the Atari than I have
time to explain for this to make much sense, but perhaps it will pique your
curiousity? If you're into programming, you might even decide to go make
your own Atari game.

; Turn off blanking and spend one line to set up the main loop.
        sta WSYNC
        stx VBLANK     ; 0  +3
        ; No playfield on setup line.
        stx PF1        ; 3  +3
        stx PF2        ; 6  +3

        ; The Picture loop begins at the end of a scanline, so wait until the
        ; end of the setup line to do loop setup.
        ldx #9         ; 9  +2
PrePic  dex            ; 11 +5(n-1)+4
        bne PrePic     ; 

        ldx #0         ; 55 +2
        ldy SPRITE_Y   ; 57 +3
        lda #$80       ; 60 +2
        sta R1         ; 62 +3
        lda FB0        ; 65 +3 Set up initial PF1 data.
        dey            ; 68 +2
        bne Picture    ; 70 +3

; X is the framebuffer row number in 0..15.
; R1 is a one-hot counter which sets the carry bit every 8 cycles
; to trigger incrementing the framebuffer row.
.newr   nop            ; 43 +2
        sta PF2        ; 45 +3
        lda FB3,x      ; 48 +4
        inx            ; 52 +2
        cpx #16        ; 54 +2
        sta PF1        ; 56 +3
        beq Status     ; 59 +2
        lda #$80       ; 61 +2
        sta.w R1       ; 63 +4
        lda FB0,x      ; 67 +4
        dey            ; 71 +2
Picture sta PF1        ; 73 +3 Store PF1 data.
        bmi .nosp1     ; 0  +2 If y < 0, not in sprite.
        cpy #SPRITEH   ; 2  +2 Test y against sprite height.
        bcs .nosp2         ; 4  +2 If y >= H, not in sprite.
.sprite lda (SPRITE_P),y   ; 6  +5 Load sprite bitmap row.
        sta GRP0           ; 11 +3 Store sprite bitmap row.
        lda SpriteColor,y  ; 14 +4 Load sprite row color.
        sta COLUP0         ; 18 +3 Store sprite row color.
        ; Render playfield from framebuffer.
.pf     lda R1         ; 21 +3 Get ring counter.
        lsr            ; 24 +2 Count line, set carry if row changes.
        sta R1         ; 26 +3 Save ring counter.
        lda FB1,x      ; 29 +4 Get data for PF2.
        sta PF2        ; 33 +3 Store PF2 data.
        lda FB2,x      ; 36 +4 Get data for new PF2.
        bcs .newr      ; 40 +2 Branch if next line is new row.
        SLEEP 3        ; 42 +3
.samer  sta PF2        ; 45 +3 Set new PF2 just before it starts.
        lda FB3,x      ; 48 +4 Get data for PF1.
        SLEEP 3        ; 52 +3
        sta PF1        ; 55 +3 Store PF1 data.
        lda FB0,x      ; 58 +4 Get next line PF1 data.
        SLEEP 6        ; 62 +6
        dey            ; 68 +2 Next sprite line.
        bvc Picture    ; 70 +3 Always taken.
.nosp1  SLEEP 4        ; 3  +4 Delay to match sprite lines.
.nosp2  cpy #20        ; 7  +2 20 pixels above sprite or less?
        bcs .bl        ; 9  +2 No, black out playfield.
        lda PFCol,y    ; 11 +4 Get color for this height.
        sta COLUPF     ; 15 +3 Set playfield color.
        bvc .pf        ; 18 +3 Always taken.
.bl     lda PFINV      ; 12 +3 Get invisible playfield color.
        sta COLUPF     ; 15 +3 Set playfield color.
        bvc .pf        ; 18 +3 Always taken.
